# Commit to git repository with the user name and email address of a specific (machine) user.
# The user name and email address must be associated with a GitHub account.
# Independently of the git user configuration, a valid GitHub user or app is required to
# authenticate with GitHub in order to be able to push the commit.
# The authentication is via the Azure Pipelines App.
# The remote branch must accept an unsigned commit from the user. I.E. signing is not enforced or
# there is a bypass for the user (for the role or team they are a member of).

trigger: none
pr: none

resources:
  repositories:
  - repository: update
    type: github
    name: 'ullet-experiments/ado-github-signed-commits'
    endpoint: ullet
    ref: 'refs/heads/main'

pool:
  vmImage: ubuntu-latest

steps:
- checkout: update
  persistCredentials: true
  # Set a path that is NOT inside the default sources directory ($(Pipeline.Workspace)/s) so that
  # the files to be modified and committed to the repo are kept separate from any source files to be
  # used in a built. (Unless the modified file is part of the source to be built, e.g. modifying
  # a config file to update a version string, and want to commit that change on a successful build).
  # Path must be relative to $(Pipeline.Workspace). It can't be a rooted directory.
  path: 'update'

- task: PowerShell@2
  displayName: Update file in GIT repository
  inputs:
    targetType: 'inline'
    script: |
      # User email and name must be set to be able to commit.
      # Use an email address validated for a GitHub (machine) user account.
      git config user.email "inherently-biased@users.noreply.github.com"
      git config user.name "$(Build.RequestedFor)"

      # Debug output.
      git config

      # Pipeline checkout always results in a 'detached HEAD' state.
      # Need to switch to a branch before can commit any files.
      git fetch --all
      git switch main

      $timeStamp = Get-Date -AsUTC -Format "yyyy-MM-ddTHH:mm:ssZ"
      $logEntry = "${timeStamp}: $(Build.BuildId), $(Build.BuildNumber), $(Build.Reason), $(Build.SourceBranch), $(Build.SourceVersion)"
      $logEntry | Out-File -Append -FilePath log.txt

      # Debug output.
      Get-Content log.txt

      git add log.txt

      # Debug output.
      git status

      # Signed commits are either not required or the a bypass exists for the committer for all
      # rules enforcing signed commits.
      git commit -m "Update log" -m "[skip ci]"

      # Debug output.
      git status

      git push
    pwsh: true
    # Don't use 'Build.Repository.LocalPath' or 'Build.SourcesDirectory' as those variables depend
    # on whether multiple repositories have been checked out (e.g. might also 'checkout: self').
    # Set the working directory path to the path used in 'checkout'.
    workingDirectory: '$(Pipeline.Workspace)/update'
